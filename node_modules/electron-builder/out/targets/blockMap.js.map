{"version":3,"file":"blockMap.js","sourceRoot":"","sources":["../../src/targets/blockMap.ts"],"names":[],"mappings":"AAAA,AAAO,AAAe,AAAM,AAAc;;;;;;;;;;;;;;;;;;;;oEAK1C,AAAK,WAAwB,AAAU,IAAE,AAAqB;AAC5D,cAAM,AAAS,YAAG,AAAE,KAAG,AAAI;AAC3B,cAAM,AAAM,SAAG,AAAM,OAAC,AAAW,YAAC,AAAS,AAAC;AAC5C,cAAM,AAAM,SAAG,AAAE;AAEjB,AAAG,AAAC,aAAC,IAAI,AAAM,SAAG,AAAK,MAAC,AAAK,OAAE,AAAM,SAAG,AAAK,MAAC,AAAG,KAAE,AAAM,UAAI,AAAS,WAAE,AAAC;AACvE,kBAAM,AAAe,kBAAG,AAAI,KAAC,AAAG,IAAC,AAAK,MAAC,AAAG,MAAG,AAAM,QAAE,AAAS,AAAC;AAC/D,kBAAM,AAAI,0CAAC,AAAE,IAAE,AAAM,QAAE,AAAC,GAAE,AAAe,iBAAE,AAAM,AAAC;AAElD,kBAAM,AAAI,OAAG,AAAU,4CAAC,AAAQ,AAAC;AACjC,AAAI,iBAAC,AAAM,OAAC,AAAe,oBAAK,AAAS,YAAG,AAAM,SAAG,AAAM,OAAC,AAAK,MAAC,AAAC,GAAE,AAAe,AAAC,AAAC;AACtF,AAAM,mBAAC,AAAI,KAAC,AAAI,KAAC,AAAM,OAAC,AAAQ,AAAC,AAAC,AACpC;AAAC;AAED,AAAM,eAAC,AAAM,AACf;AAAC,AAED,AAAM;;;;;;;;qEAAC,AAAK,WAA0B,AAAmB,aAAE,AAAyB,mBAAE,AAAuB;AAC3G,cAAM,AAAG,MAAG,MAAM,AAAO,mCAAC,AAAW,AAAC;AACtC,YAAI,AAAC;AACH,kBAAM,AAAO,UAAG,MAAM,AAAG,IAAC,AAAW,AAAE;AACvC,kBAAM,AAAK,QAAG,sDAAsB,AAAG,IAAC,AAAO;AAA3B,AAAe,iFAAc,AAAK,WAAC,AAAK;AAC1D,0BAAM,AAAM,SAAG,MAAM,AAAa,cAAC,AAAG,IAAC,AAAE,KAAE,MAAM,AAAG,IAAC,AAAe,gBAAC,AAAK,AAAC,AAAC;AAC5E,AAAM;AACJ,AAAI,8BAAG,AAAK,MAAC,AAAmB,SAAC,AAAO,QAAC,AAAK,OAAE,AAAG,AAAC;AACpD,AAAI,8BAAE,AAAK,MAAC,AAAc;AAC1B,AAAM,AACP,AACH;AALS;AAKR;;;;;kBAAE,EAAC,AAAW,aAAE,AAAC,AAAC,AAAC;AACpB,AAAM;AACJ,AAAS,2BAAE,AAAE;AACb,AAAU,4BAAE,AAAQ;AACpB,AAAiB;AACjB,AAAgB;AAChB,AAAK,AACN,AACH;AAPS;AAOR,kBACO,AAAC;AACP,kBAAM,AAAG,IAAC,AAAK,AAAE,AACnB;AAAC,AACH;AAAC;;;;;;;;;;;AA5CD,AAAO,AAAE,AAAU,AAAE,AAAM,AAAQ;;;;;;AACnC,AAAO,AAAE,AAAI,AAAE,AAAM,AAAY;;;;;;AACjC,AAAO,AAAkB,AAAO,AAAE,AAAM,AAAY","sourcesContent":["import BluebirdPromise from \"bluebird-lst\"\nimport { createHash } from \"crypto\"\nimport { read } from \"fs-extra-p\"\nimport { EntryDataRange, openZip } from \"./nsis/zip\"\n\nasync function computeBlocks(fd: number, range: EntryDataRange): Promise<Array<string>> {\n  const chunkSize = 64 * 1024\n  const buffer = Buffer.allocUnsafe(chunkSize)\n  const blocks = []\n\n  for (let offset = range.start; offset < range.end; offset += chunkSize) {\n    const actualChunkSize = Math.min(range.end - offset, chunkSize)\n    await read(fd, buffer, 0, actualChunkSize, offset)\n\n    const hash = createHash(\"sha256\")\n    hash.update(actualChunkSize === chunkSize ? buffer : buffer.slice(0, actualChunkSize))\n    blocks.push(hash.digest(\"base64\"))\n  }\n\n  return blocks\n}\n\nexport async function computeBlockMap(archiveFile: string, compressionMethod: \"lzma\", compressionLevel: 9 | 1): Promise<BlockMap> {\n  const zip = await openZip(archiveFile)\n  try {\n    const entries = await zip.readEntries()\n    const files = await BluebirdPromise.map(entries, async entry => {\n      const blocks = await computeBlocks(zip.fd, await zip.getDataPosition(entry))\n      return {\n        name: (entry.fileName as string).replace(/\\\\/g, \"/\"),\n        size: entry.compressedSize,\n        blocks,\n      }\n    }, {concurrency: 8})\n    return {\n      blockSize: 64,\n      hashMethod: \"sha256\",\n      compressionMethod,\n      compressionLevel,\n      files,\n    }\n  }\n  finally {\n    await zip.close()\n  }\n}\n\nexport interface BlockMap {\n  blockSize: number\n  hashMethod: \"sha256\"\n\n  // https://sourceforge.net/p/sevenzip/discussion/45798/thread/222c71f9/?limit=25\n  compressionMethod: \"lzma\"\n  compressionLevel: 9 | 1\n\n  files: Array<BlockMapFile>\n}\n\nexport interface BlockMapFile {\n  name: string\n  size: number\n\n  // size of block 64K, last block size `size % (64 * 1024)`\n  blocks: Array<string>\n}"]}
