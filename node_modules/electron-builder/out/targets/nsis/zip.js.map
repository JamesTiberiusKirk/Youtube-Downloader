{"version":3,"file":"zip.js","sourceRoot":"","sources":["../../../src/targets/nsis/zip.ts"],"names":[],"mappings":";;;;;;;;;;;;;;oEAYO,AAAK,WAAkB,AAAY,MAAE,AAA2B;AACrE,cAAM,AAAY,+BAChB,AAAc,gBAAE,AAAI,MACpB,AAAkB,oBAAE,AAAI,MACxB,AAAa,eAAE,AAAI,QAChB,AAAO,AACX;AAED,cAAM,AAAE,KAAG,MAAM,AAAI,0CAAC,AAAI,MAAE,AAAG,AAAC;AAChC,YAAI,AAAC;AACH,kBAAM,AAAK,QAAG,MAAM,AAAK,2CAAC,AAAE,AAAC;AAC7B,AAAM,mBAAC,MAAM,AAA+B,gCAAC,AAAE,IAAE,AAAK,MAAC,AAAI,MAAE,AAAY,AAAC,AAC5E;AAAC,UACD,AAAK,AAAC,OAAC,AAAC,AAAC,GAAC,AAAC;AACT,kBAAM,AAAS,2CAAC,AAAE,AAAC;AACnB,kBAAM,AAAC,AACT;AAAC,AACH;AAAC;;;;;;;;qEAED,AAAK,WAA0C,AAAU,IAAE,AAAiB,WAAE,AAAmB;AAC/F,cAAM,AAAa,gBAAG,AAAO,QAAC,AAAa;AAC3C,AAAE,AAAC,YAAC,AAAS,YAAG,AAAM,OAAC,AAAgB,AAAC,kBAAC,AAAC;AACxC,kBAAM,IAAI,AAAK,MAAC,AAAwH,AAAC,AAC3I;AAAC;AAED,AAA+C;AAC/C,AAA4C;AAC5C,AAA4D;AAC5D,AAA6I;AAC7I,AAAsI;AACtI,AAAoJ;AACpJ,cAAM,AAAuB,0BAAG,AAAE;AAClC,cAAM,AAAc,iBAAG,AAAM,QAAC,AAAc;AAC5C,cAAM,AAAU,aAAG,AAAI,KAAC,AAAG,IAAC,AAAuB,0BAAG,AAAc,gBAAE,AAAS,AAAC;AAChF,cAAM,AAAM,SAAG,AAAM,OAAC,AAAW,YAAC,AAAU,AAAC;AAC7C,cAAM,AAAe,kBAAG,AAAS,YAAG,AAAM,OAAC,AAAM;AAEjD,cAAM,AAAkB,mBAAC,AAAE,IAAE,AAAM,QAAE,AAAC,GAAE,AAAU,YAAE,AAAe,AAAC;AACpE,AAAG,AAAC,aAAC,IAAI,AAAC,IAAG,AAAU,aAAG,AAAuB,yBAAE,AAAC,KAAI,AAAC,GAAE,AAAC,AAAE,KAAE,AAAC;AAC/D,AAAE,AAAC,gBAAC,AAAM,OAAC,AAAY,aAAC,AAAC,AAAC,OAAK,AAAU,AAAC,YAAC,AAAC;AAC1C,AAAQ,AACV;AAAC;AAED,AAAc;AACd,kBAAM,AAAW,cAAG,AAAM,OAAC,AAAK,MAAC,AAAC,AAAC;AAEnC,AAAsD;AACtD,AAA0B;AAC1B,kBAAM,AAAU,aAAG,AAAW,YAAC,AAAY,aAAC,AAAC,AAAC;AAC9C,AAAE,AAAC,gBAAC,AAAU,eAAK,AAAC,AAAC,GAAC,AAAC;AACrB,sBAAM,IAAI,AAAK,AAAC,oEAA8D,AAAU,UAAE,AAAC,AAC7F;AAAC;AAED,AAA0C;AAC1C,AAAuD;AACvD,AAAiD;AACjD,gBAAI,AAAU,aAAG,AAAW,YAAC,AAAY,aAAC,AAAE,AAAC;AAC7C,AAAyC;AACzC,kBAAM,AAAoB,uBAAG,AAAW,YAAC,AAAY,aAAC,AAAE,AAAC;AACzD,AAA0E;AAC1E,gBAAI,AAAsB,yBAAG,AAAW,YAAC,AAAY,aAAC,AAAE,AAAC;AACzD,AAAsB;AACtB,kBAAM,AAAa,gBAAG,AAAW,YAAC,AAAY,aAAC,AAAE,AAAC;AAClD,kBAAM,AAAqB,wBAAG,AAAW,YAAC,AAAM,SAAG,AAAuB;AAC1E,AAAE,AAAC,gBAAC,AAAa,kBAAK,AAAqB,AAAC,uBAAC,AAAC;AAC5C,sBAAM,IAAI,AAAK,AAAC,2CAAqC,AAAqB,iCAAY,AAAa,aAAE,AAAC,AACxG;AAAC;AACD,AAAe;AACf,AAAgC;AAChC,kBAAM,AAAO,UAAG,AAAO,QAAC,AAAc,iBAAG,AAAE,AAAG,KAAC,AAAa,gBAAG,AAAY,aAAC,AAAW,aAAE,AAAE,IAAE,AAAW,YAAC,AAAM,QAAE,AAAK,AAAC,SAAG,AAAW,YAAC,AAAK,MAAC,AAAE,AAAC,AAAC;AAEhJ,AAAE,AAAC,gBAAC,AAAC,EAAC,AAAU,eAAK,AAAM,UAAI,AAAsB,2BAAK,AAAU,AAAC,AAAC,aAAC,AAAC;AACtE,AAAM,uBAAC,IAAI,AAAO,QAAC,AAAE,IAAE,AAAoB,sBAAE,AAAsB,wBAAE,AAAS,WAAE,AAAU,YAAE,AAAO,SAAE,AAAO,AAAC,AAC/G;AAAC;AAED,AAAe;AAEf,AAA+C;AAC/C,kBAAM,AAAgB,mBAAG,AAAM,OAAC,AAAW,YAAC,AAAE,AAAC;AAC/C,kBAAM,AAAgB,mBAAG,AAAe,kBAAG,AAAC,IAAG,AAAgB,iBAAC,AAAM;AACtE,kBAAM,AAAkB,mBAAC,AAAE,IAAE,AAAgB,kBAAE,AAAC,GAAE,AAAgB,iBAAC,AAAM,QAAE,AAAgB,AAAC;AAE5F,AAA8D;AAC9D,AAAE,AAAC,gBAAC,AAAgB,iBAAC,AAAY,aAAC,AAAC,AAAC,OAAK,AAAU,AAAC,YAAC,AAAC;AACpD,sBAAM,IAAI,AAAK,MAAC,AAA0D,AAAC,AAC7E;AAAC;AAED,AAA8E;AAC9E,AAAmE;AACnE,kBAAM,AAAgB,mBAAG,AAAY,aAAC,AAAgB,kBAAE,AAAC,AAAC;AAC1D,AAA6B;AAE7B,AAAwC;AACxC,kBAAM,AAAgB,mBAAG,AAAM,OAAC,AAAW,YAAC,AAAE,AAAC;AAC/C,kBAAM,AAAkB,mBAAC,AAAE,IAAE,AAAgB,kBAAE,AAAC,GAAE,AAAgB,iBAAC,AAAM,QAAE,AAAgB,AAAC;AAC5F,AAAyF;AACzF,AAAE,AAAC,gBAAC,AAAgB,iBAAC,AAAY,aAAC,AAAC,AAAC,OAAK,AAAU,AAAC,YAAC,AAAC;AACpD,sBAAM,IAAI,AAAK,MAAC,AAAyD,AAAC,AAC5E;AAAC;AACD,AAA2E;AAC3E,AAA2E;AAC3E,AAA2E;AAC3E,AAA2E;AAC3E,AAA2E;AAC3E,AAAqF;AACrF,AAA2E;AAC3E,AAAU,yBAAG,AAAY,aAAC,AAAgB,kBAAE,AAAE,AAAC;AAC/C,AAA2E;AAC3E,AAAiG;AACjG,AAAsB,qCAAG,AAAY,aAAC,AAAgB,kBAAE,AAAE,AAAC;AAC3D,AAAmF;AACnF,AAAM,mBAAC,IAAI,AAAO,QAAC,AAAE,IAAE,AAAY,aAAC,AAAgB,kBAAE,AAAE,AAAC,KAAE,AAAsB,wBAAE,AAAS,WAAE,AAAU,YAAE,AAAO,SAAE,AAAO,AAAC,AAC7H;AAAC;AAED,cAAM,IAAI,AAAK,MAAC,AAAqD,AAAC,AACxE;AAAC,AAED,AAAM;;;;;;;;qEAmTN,AAAK,WAA6B,AAAU,IAAE,AAAc,QAAE,AAAc,QAAE,AAAc,QAAE,AAAgB;AAC5G,AAAE,AAAC,YAAC,AAAM,WAAK,AAAC,AAAC,GAAC,AAAC;AACjB,AAA0F;AAC1F,AAAM,mBAAC,AAAM,OAAC,AAAK,MAAC,AAAC,AAAC,AACxB;AAAC;AAED,AAA0C;AAC1C,cAAM,AAAM,SAAG,MAAM,AAAI,0CAAC,AAAE,IAAE,AAAM,QAAE,AAAM,QAAE,AAAM,QAAE,AAAQ,AAAC;AAC/D,AAA8B;AAC9B,AAAmD;AACnD,AAAM;AACN,AAAM,eAAC,AAAM,AACf;AAAC;;;;;;;;;AAhcD,AAAO,AAAE,AAAY,AAAE,AAAM,AAAQ;;;;;;AACrC,AAAO,AAAE,AAAK,AAAI,AAAS,AAAE,AAAK,AAAE,AAAI,AAAE,AAAI,AAAE,AAAM,AAAY,AAWlE,AAAM;;;;MAqHe,AAAQ,AAAY;AAIvC,AAAqC;AACrC,gBAAqB,AAAU,IAAW,AAA4B,sBAAW,AAA8B,wBAAW,AAAgB,UAAW,AAAkB,YAAW,AAAY,SAAW,AAAmB;AAC1N,AAAK,AAAE;AADY,aAAE,KAAF,AAAE,AAAQ;AAAW,aAAoB,uBAApB,AAAoB,AAAQ;AAAW,aAAsB,yBAAtB,AAAsB,AAAQ;AAAW,aAAQ,WAAR,AAAQ,AAAQ;AAAW,aAAU,aAAV,AAAU,AAAQ;AAAW,aAAO,UAAP,AAAO,AAAK;AAAW,aAAO,UAAP,AAAO,AAAY;AAJpN,aAAe,kBAAG,AAAC;AACnB,aAAM,SAAG,AAAI,AAKrB;AAAC;AAEK,AAAW,eAAjB,AAAK;;;;AACH,AAAI,kBAAC,AAAe,kBAAG,AAAC;AACxB,kBAAM,AAAM,SAAG,AAAM,OAAC,AAAW,YAAC,AAAI,MAAC,AAAoB,AAAC;AAC5D,kBAAM,AAAkB,mBAAC,AAAI,MAAC,AAAE,IAAE,AAAM,QAAE,AAAC,GAAE,AAAM,OAAC,AAAM,QAAE,AAAI,MAAC,AAAsB,AAAC;AAExF,kBAAM,AAAO,UAAG,IAAI,AAAK,MAAQ,AAAI,MAAC,AAAU,AAAC;AACjD,AAAG,AAAC,iBAAC,IAAI,AAAC,IAAG,AAAC,GAAE,AAAC,IAAG,AAAI,MAAC,AAAU,YAAE,AAAC,AAAE,KAAE,AAAC;AACzC,AAAO,wBAAC,AAAC,AAAC,KAAG,AAAI,MAAC,AAAS,UAAC,AAAM,AAAC,AACrC;AAAC;AACD,AAAM,mBAAC,AAAO,AAChB;;AAAC;AAEK,AAAK,SAAX,AAAK;;;;AACH,AAAE,AAAC,gBAAC,CAAC,AAAI,OAAC,AAAM,AAAC,QAAC,AAAC;AACjB,AAAM,AACR;AAAC;AAED,AAAI,mBAAC,AAAM,SAAG,AAAK;AACnB,AAAM,mBAAC,AAAS,2CAAC,AAAI,OAAC,AAAE,AAAC,AAC3B;;AAAC;AAEO,AAAS,cAAC,AAAc;AAC9B,cAAM,AAAK,QAAG,IAAI,AAAK,AAAE;AACzB,AAA8C;AAC9C,cAAM,AAAS,YAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,AAAC;AAC3D,AAAE,AAAC,YAAC,AAAS,cAAK,AAAU,AAAC,YAAC,AAAC;AAC7B,kBAAM,IAAI,AAAK,AAAC,4DAAsD,AAAS,UAAC,AAAQ,SAAC,AAAE,AAAC,GAAE,AAAC,AACjG;AAAC;AAED,AAAsB;AACtB,AAAK,cAAC,AAAa,gBAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAC,AAAC;AACnE,AAA0C;AAC1C,AAAK,cAAC,AAAsB,yBAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAC,AAAC;AAC5E,AAA+B;AAC/B,AAAK,cAAC,AAAqB,wBAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAC,AAAC;AAC3E,AAA0B;AAC1B,AAAK,cAAC,AAAiB,oBAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAE,AAAC;AACxE,AAAmC;AACnC,AAAK,cAAC,AAAe,kBAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAE,AAAC;AACtE,AAAmC;AACnC,AAAK,cAAC,AAAe,kBAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAE,AAAC;AACtE,AAAc;AACd,AAAK,cAAC,AAAK,QAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAE,AAAC;AAC5D,AAAuB;AACvB,AAAK,cAAC,AAAc,iBAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAE,AAAC;AACrE,AAAyB;AACzB,AAAK,cAAC,AAAgB,mBAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAE,AAAC;AACvE,AAA4B;AAC5B,AAAK,cAAC,AAAc,iBAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAE,AAAC;AACrE,AAA8B;AAC9B,AAAK,cAAC,AAAgB,mBAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAE,AAAC;AACvE,AAA+B;AAC/B,AAAK,cAAC,AAAiB,oBAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAE,AAAC;AACxE,AAAqC;AACrC,AAAgC;AAChC,AAAK,cAAC,AAAsB,yBAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAE,AAAC;AAC7E,AAAgC;AAChC,AAAK,cAAC,AAAsB,yBAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAE,AAAC;AAC7E,AAA4C;AAC5C,AAAK,cAAC,AAA2B,8BAAG,AAAM,OAAC,AAAY,aAAC,AAAI,KAAC,AAAe,kBAAG,AAAE,AAAC;AAElF,AAAE,AAAC,YAAC,AAAK,MAAC,AAAqB,wBAAG,AAAI,AAAC,MAAC,AAAC;AACvC,kBAAM,IAAI,AAAK,MAAC,AAAoC,AAAC,AACvD;AAAC;AAED,AAAI,aAAC,AAAe,mBAAI,AAAE;AAC1B,cAAM,AAAa,gBAAG,AAAK,MAAC,AAAc,iBAAG,AAAK,MAAC,AAAgB,mBAAG,AAAK,MAAC,AAAiB;AAC7F,AAAM,iBAAG,AAAM,OAAC,AAAK,MAAC,AAAI,KAAC,AAAe,iBAAE,AAAI,KAAC,AAAe,kBAAG,AAAa,AAAC;AACjF,AAAI,aAAC,AAAe,mBAAI,AAAa;AAErC,AAAiB;AACjB,cAAM,AAAM,SAAG,CAAC,AAAK,MAAC,AAAqB,wBAAG,AAAK,AAAC,WAAK,AAAC;AAC1D,AAAK,cAAC,AAAQ,WAAG,AAAI,KAAC,AAAO,QAAC,AAAa,gBAAG,AAAY,aAAC,AAAM,QAAE,AAAC,GAAE,AAAK,MAAC,AAAc,gBAAE,AAAM,AAAC,UAAG,AAAM,OAAC,AAAK,MAAC,AAAC,GAAE,AAAK,MAAC,AAAc,AAAC;AAE3I,AAAqB;AACrB,cAAM,AAAgB,mBAAG,AAAK,MAAC,AAAc,iBAAG,AAAK,MAAC,AAAgB;AACtE,AAAe,wBAAC,AAAM,OAAC,AAAK,MAAC,AAAK,MAAC,AAAc,gBAAE,AAAgB,AAAC,mBAAE,AAAK,AAAC;AAE5E,AAAwB;AACxB,AAAE,AAAC,YAAC,CAAC,AAAI,KAAC,AAAO,QAAC,AAAc,AAAC,gBAAC,AAAC;AACjC,AAAE,AAAC,gBAAC,AAAI,KAAC,AAAO,QAAC,AAAa,AAAC,eAAC,AAAC;AAC/B,AAAK,sBAAC,AAAW,cAAG,AAAY,aAAC,AAAM,QAAE,AAAgB,kBAAE,AAAgB,mBAAG,AAAK,MAAC,AAAiB,mBAAE,AAAM,AAAC,AAChH;AAAC,AACD,AAAI,mBAAC,AAAC;AACJ,AAAK,sBAAC,AAAW,cAAG,AAAM,OAAC,AAAK,MAAC,AAAgB,kBAAE,AAAgB,mBAAG,AAAK,MAAC,AAAiB,AAAC,AAChG;AAAC,AACH;AAAC;AAED,AAAc,uBAAC,AAAK,AAAC;AAErB,AAAuD;AACvD,AAAsD;AACtD,AAAE,AAAC,YAAC,AAAI,KAAC,AAAO,QAAC,AAAa,AAAC,eAAC,AAAC;AAC/B,AAAG,AAAC,iBAAC,MAAM,AAAU,cAAI,AAAK,MAAC,AAAW,AAAC,aAAC,AAAC;AAC3C,AAAE,AAAC,oBAAC,AAAU,WAAC,AAAE,OAAK,AAAM,AAAC,QAAC,AAAC;AAC7B,AAAE,AAAC,wBAAC,AAAU,WAAC,AAAI,KAAC,AAAM,SAAG,AAAC,AAAC,GAAC,AAAC;AAC/B,AAA6B;AAC7B,AAAQ,AACV;AAAC;AACD,AAAqE;AACrE,AAAE,AAAC,wBAAC,AAAU,WAAC,AAAI,KAAC,AAAS,UAAC,AAAC,AAAC,OAAK,AAAC,AAAC,GAAC,AAAC;AACvC,AAAyD;AACzD,AAA+D;AAC/D,AAAQ,AACV;AAAC;AACD,AAA2D;AAC3D,AAAuD;AACvD,AAAgF;AAChF,AAAuE;AACvE,AAA+E;AAC/E,AAAa;AACb,AAAI;AACJ,AAAiE;AACjE,AAAK,0BAAC,AAAQ,WAAG,AAAY,aAAC,AAAU,WAAC,AAAI,MAAE,AAAC,GAAE,AAAU,WAAC,AAAI,KAAC,AAAM,QAAE,AAAI,AAAC;AAC/E,AAAK,AACP;AAAC,AACH;AAAC,AACH;AAAC;AAED,AAAqB;AACrB,AAAE,AAAC,YAAC,AAAI,KAAC,AAAO,QAAC,AAAkB,sBAAI,AAAK,MAAC,AAAiB,sBAAK,AAAC,AAAC,GAAC,AAAC;AACrE,gBAAI,AAAsB,yBAAG,AAAK,MAAC,AAAgB;AACnD,AAAE,AAAC,gBAAC,AAAK,MAAC,AAAW,AAAC,aAAC,AAAC;AACtB,AAA8D;AAC9D,AAAsB,0CAAI,AAAE,AAC9B;AAAC;AACD,AAAE,AAAC,gBAAC,AAAK,MAAC,AAAc,mBAAK,AAAsB,AAAC,wBAAC,AAAC;AACpD,sBAAM,IAAI,AAAK,MAAC,AAAyD,4DAAG,AAAK,MAAC,AAAc,iBAAG,AAAM,SAAG,AAAK,MAAC,AAAgB,AAAC,AACrI;AAAC,AACH;AAAC;AAED,AAAE,AAAC,YAAC,AAAI,KAAC,AAAO,QAAC,AAAa,AAAC,eAAC,AAAC;AAC/B,kBAAM,AAAY,eAAG,AAAgB,iBAAC,AAAK,MAAC,AAAkB,AAAC;AAC/D,AAAE,AAAC,gBAAC,AAAY,gBAAI,AAAI,AAAC,MAAC,AAAC;AACzB,sBAAM,IAAI,AAAK,MAAC,AAAY,AAAC,AAC/B;AAAC,AACH;AAAC;AACD,AAAM,eAAC,AAAK,AACd;AAAC;AAEK,AAAe,mBAArB,AAAK,CAAiB,AAAY;;;;AAChC,kBAAM,AAAM,SAAG,AAAM,OAAC,AAAW,YAAC,AAAE,AAAC;AACrC,kBAAM,AAAkB,mBAAC,AAAI,OAAC,AAAE,IAAE,AAAM,QAAE,AAAC,GAAE,AAAM,OAAC,AAAM,QAAE,AAAK,MAAC,AAA2B,AAAC;AAC9F,AAA+C;AAC/C,kBAAM,AAAS,YAAG,AAAM,OAAC,AAAY,aAAC,AAAC,AAAC;AACxC,AAAE,AAAC,gBAAC,AAAS,cAAK,AAAU,AAAC,YAAC,AAAC;AAC7B,sBAAM,IAAI,AAAK,AAAC,gDAA0C,AAAS,UAAC,AAAQ,SAAC,AAAE,AAAC,GAAE,AAAC,AACrF;AAAC;AAED,AAA+B;AAC/B,AAA0C;AAC1C,AAA+B;AAC/B,AAAyB;AACzB,AAAmC;AACnC,AAAmC;AACnC,AAAc;AACd,AAAuB;AACvB,AAAyB;AACzB,AAA4B;AAC5B,kBAAM,AAAc,iBAAG,AAAM,OAAC,AAAY,aAAC,AAAE,AAAC;AAC9C,AAA8B;AAC9B,kBAAM,AAAgB,mBAAG,AAAM,OAAC,AAAY,aAAC,AAAE,AAAC;AAChD,AAAiB;AACjB,AAAqB;AACrB,kBAAM,AAAa,gBAAG,AAAK,MAAC,AAA2B,8BAAG,AAAM,OAAC,AAAM,SAAG,AAAc,iBAAG,AAAgB;AAC3G,kBAAM,AAAW,cAAG,AAAa,gBAAG,AAAK,MAAC,AAAc;AACxD,AAAE,AAAC,gBAAC,AAAK,MAAC,AAAc,mBAAK,AAAC,AAAC,GAAC,AAAC;AAC/B,AAAqF;AACrF,AAAwG;AACxG,AAAE,AAAC,oBAAC,AAAW,cAAG,AAAI,OAAC,AAAQ,AAAC,UAAC,AAAC;AAChC,0BAAM,IAAI,AAAK,AAAC,0CAAoC,AAAa,mBAAM,AAAK,MAAC,AAAc,oBAAM,AAAI,OAAC,AAAQ,QAAE,AAAC,AACnH;AAAC,AACH;AAAC;AAED,AAAM;AACJ,AAAK,uBAAE,AAAa;AACpB,AAAG,qBAAE,AAAa,gBAAG,AAAK,MAAC,AAAc,AAC1C,AACH;AAJS;;AAIR,AACF;;;AAOD,yBAAyB,AAAwB,kBAAE,AAAY;AAC7D,AAAK,UAAC,AAAW,cAAG,AAAE;AACtB,QAAI,AAAC,IAAG,AAAC;AACT,WAAO,AAAC,IAAG,AAAgB,iBAAC,AAAM,SAAG,AAAC,GAAE,AAAC;AACvC,cAAM,AAAQ,WAAG,AAAgB,iBAAC,AAAY,aAAC,AAAC,AAAC;AACjD,cAAM,AAAQ,WAAG,AAAgB,iBAAC,AAAY,aAAC,AAAC,IAAG,AAAC,AAAC;AACrD,cAAM,AAAS,YAAG,AAAC,IAAG,AAAC;AACvB,cAAM,AAAO,UAAG,AAAS,YAAG,AAAQ;AACpC,AAAE,AAAC,YAAC,AAAO,UAAG,AAAgB,iBAAC,AAAM,AAAC,QAAC,AAAC;AACtC,kBAAM,IAAI,AAAK,MAAC,AAAoD,AAAC,AACvE;AAAC;AACD,cAAM,AAAU,aAAG,AAAM,OAAC,AAAW,YAAC,AAAQ,AAAC;AAC/C,AAAgB,yBAAC,AAAI,KAAC,AAAU,YAAE,AAAC,GAAE,AAAS,WAAE,AAAO,AAAC;AACxD,AAAK,cAAC,AAAW,YAAC,AAAI;AACpB,AAAE,gBAAE,AAAQ;AACZ,AAAI,kBAAE,AAAU,AACjB,AAAC;AAHqB;AAIvB,AAAC,YAAG,AAAO,AACb;AAAC,AACH;AAAC;AAED,wBAAwB,AAAY;AAClC,AAAE,AAAC,QAAC,AAAK,MAAC,AAAgB,qBAAK,AAAU,cACvC,AAAK,MAAC,AAAc,mBAAK,AAAU,cACnC,AAAK,MAAC,AAA2B,gCAAK,AAAU,AAAC,YAAC,AAAC;AACnD,AAAe;AACf,AAAkD;AAClD,YAAI,AAAe,kBAAG,AAAI;AAC1B,AAAG,AAAC,aAAC,MAAM,AAAU,cAAI,AAAK,MAAC,AAAW,AAAC,aAAC,AAAC;AAC3C,AAAE,AAAC,gBAAC,AAAU,WAAC,AAAE,OAAK,AAAM,AAAC,QAAC,AAAC;AAC7B,AAAe,kCAAG,AAAU,WAAC,AAAI;AACjC,AAAK,AACP;AAAC,AACH;AAAC;AACD,AAAE,AAAC,YAAC,AAAe,mBAAI,AAAI,AAAC,MAAC,AAAC;AAC5B,kBAAM,IAAI,AAAK,MAAC,AAAiD,AAAC,AACpE;AAAC;AACD,YAAI,AAAK,QAAG,AAAC;AACb,AAAqC;AACrC,AAAE,AAAC,YAAC,AAAK,MAAC,AAAgB,qBAAK,AAAU,AAAC,YAAC,AAAC;AAC1C,AAAE,AAAC,gBAAC,AAAK,QAAG,AAAC,IAAG,AAAe,gBAAC,AAAM,AAAC,QAAC,AAAC;AACvC,sBAAM,IAAI,AAAK,MAAC,AAA2E,AAAC,AAC9F;AAAC;AACD,AAAK,kBAAC,AAAgB,mBAAG,AAAY,aAAC,AAAe,iBAAE,AAAK,AAAC;AAC7D,AAAK,qBAAI,AAAC,AACZ;AAAC;AACD,AAAqC;AACrC,AAAE,AAAC,YAAC,AAAK,MAAC,AAAc,mBAAK,AAAU,AAAC,YAAC,AAAC;AACxC,AAAE,AAAC,gBAAC,AAAK,QAAG,AAAC,IAAG,AAAe,gBAAC,AAAM,AAAC,QAAC,AAAC;AACvC,sBAAM,IAAI,AAAK,MAAC,AAAyE,AAAC,AAC5F;AAAC;AACD,AAAK,kBAAC,AAAc,iBAAG,AAAY,aAAC,AAAe,iBAAE,AAAK,AAAC;AAC3D,AAAK,qBAAI,AAAC,AACZ;AAAC;AACD,AAAsC;AACtC,AAAE,AAAC,YAAC,AAAK,MAAC,AAA2B,gCAAK,AAAU,AAAC,YAAC,AAAC;AACrD,AAAE,AAAC,gBAAC,AAAK,QAAG,AAAC,IAAG,AAAe,gBAAC,AAAM,AAAC,QAAC,AAAC;AACvC,sBAAM,IAAI,AAAK,MAAC,AAAgF,AAAC,AACnG;AAAC;AACD,AAAK,kBAAC,AAA2B,8BAAG,AAAY,aAAC,AAAe,iBAAE,AAAK,AAAC;AACxE,AAAkC;AAClC,AAAK,qBAAI,AAAC,AACZ;AAAC;AACD,AAAsC,AACxC;AAAC,AACH;AAAC,AAED,AAAM;;AAuBJ,QAAI,AAAW;AACb,AAAM,eAAC,CAAC,AAAI,KAAC,AAAqB,wBAAG,AAAG,AAAC,SAAK,AAAC,AACjD;AAAC;AACD,QAAI,AAAY;AACd,AAAM,eAAC,AAAI,KAAC,AAAiB,sBAAK,AAAC,AACrC;AAAC,AACF;;;AAED,0BAA0B,AAAgB;AACxC,AAAE,AAAC,QAAC,AAAQ,SAAC,AAAO,QAAC,AAAI,AAAC,UAAK,CAAC,AAAC,AAAC,GAAC,AAAC;AAClC,AAAM,eAAC,AAAkC,qCAAG,AAAQ,AACtD;AAAC;AACD,AAAE,AAAC,QAAC,AAAY,aAAC,AAAI,KAAC,AAAQ,AAAC,aAAI,AAAK,MAAC,AAAI,KAAC,AAAQ,AAAC,AAAC,WAAC,AAAC;AACxD,AAAM,eAAC,AAAiB,oBAAG,AAAQ,AACrC;AAAC;AACD,AAAE,AAAC,QAAC,AAAQ,SAAC,AAAK,MAAC,AAAG,AAAC,KAAC,AAAO,QAAC,AAAI,AAAC,UAAK,CAAC,AAAC,AAAC,GAAC,AAAC;AAC7C,AAAM,eAAC,AAAyB,4BAAG,AAAQ,AAC7C;AAAC;AACD,AAAW;AACX,AAAM,WAAC,AAAI,AACb;AAAC;;AAgBD,MAAM,AAAK,QAAG,AAAyQ;AAEvR,sBAAsB,AAAc,QAAE,AAAa,OAAE,AAAW,KAAE,AAAe;AAC/E,AAAE,AAAC,QAAC,AAAM,AAAC,QAAC,AAAC;AACX,AAAM,eAAC,AAAM,OAAC,AAAQ,SAAC,AAAM,QAAE,AAAK,OAAE,AAAG,AAAC,AAC5C;AAAC;AAED,QAAI,AAAM,SAAG,AAAE;AACf,AAAG,AAAC,SAAC,IAAI,AAAC,IAAG,AAAK,OAAE,AAAC,IAAG,AAAG,KAAE,AAAC,AAAE,KAAE,AAAC;AACjC,AAAM,kBAAI,AAAK,MAAC,AAAM,OAAC,AAAC,AAAC,AAAC,AAC5B;AAAC;AACD,AAAM,WAAC,AAAM,AACf;AAAC;AAED,sBAAsB,AAAc,QAAE,AAAc;AAClD,AAAmG;AACnG,AAAqG;AACrG,AAA6E;AAC7E,UAAM,AAAO,UAAG,AAAM,OAAC,AAAY,aAAC,AAAM,AAAC;AAC3C,UAAM,AAAO,UAAG,AAAM,OAAC,AAAY,aAAC,AAAM,SAAG,AAAC,AAAC;AAC/C,AAA+F;AAC/F,AAAM,WAAC,AAAO,UAAG,AAAW,cAAG,AAAO;AACtC,AAA4F;AAC5F,AAAuG,AACzG;AAAC","sourcesContent":["import { EventEmitter } from \"events\"\nimport { close as closeFile, fstat, open, read } from \"fs-extra-p\"\n\n// promisified and optimized version of yauzl (read Central Directory Entry buffer in one read call)\n\nexport interface ZipOptions {\n  decodeStrings?: boolean\n  validateEntrySizes?: boolean\n\n  ignoreComments?: boolean\n}\n\nexport async function openZip(file: string, options?: ZipOptions | null): Promise<ZipFile> {\n  const finalOptions: ZipOptions = {\n    ignoreComments: true,\n    validateEntrySizes: true,\n    decodeStrings: true,\n    ...options,\n  }\n\n  const fd = await open(file, \"r\")\n  try {\n    const stats = await fstat(fd)\n    return await readEndOfCentralDirectoryRecord(fd, stats.size, finalOptions)\n  }\n  catch (e) {\n    await closeFile(fd)\n    throw e\n  }\n}\n\nasync function readEndOfCentralDirectoryRecord(fd: number, totalSize: number, options: ZipOptions) {\n  const decodeStrings = options.decodeStrings\n  if (totalSize > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\"zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.\")\n  }\n\n  // eocdr means End of Central Directory Record.\n  // search backwards for the eocdr signature.\n  // the last field of the eocdr is a variable-length comment.\n  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.\n  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.\n  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.\n  const eocdrWithoutCommentSize = 22\n  const maxCommentSize = 0xffff // 2-byte size\n  const bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize)\n  const buffer = Buffer.allocUnsafe(bufferSize)\n  const bufferReadStart = totalSize - buffer.length\n\n  await readAndAssertNoEof(fd, buffer, 0, bufferSize, bufferReadStart)\n  for (let i = bufferSize - eocdrWithoutCommentSize; i >= 0; i--) {\n    if (buffer.readUInt32LE(i) !== 0x06054b50) {\n      continue\n    }\n\n    // found eocdr\n    const eocdrBuffer = buffer.slice(i)\n\n    // 0 - End of central directory signature = 0x06054b50\n    // 4 - Number of this disk\n    const diskNumber = eocdrBuffer.readUInt16LE(4)\n    if (diskNumber !== 0) {\n      throw new Error(`multi-disk zip files are not supported: found disk number: ${diskNumber}`)\n    }\n\n    // 6 - Disk where central directory starts\n    // 8 - Number of central directory records on this disk\n    // 10 - Total number of central directory records\n    let entryCount = eocdrBuffer.readUInt16LE(10)\n    // 12 - Size of central directory (bytes)\n    const centralDirectorySize = eocdrBuffer.readUInt32LE(12)\n    // 16 - Offset of start of central directory, relative to start of archive\n    let centralDirectoryOffset = eocdrBuffer.readUInt32LE(16)\n    // 20 - Comment length\n    const commentLength = eocdrBuffer.readUInt16LE(20)\n    const expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize\n    if (commentLength !== expectedCommentLength) {\n      throw new Error(`invalid comment length. expected: ${expectedCommentLength}. found: ${commentLength}`)\n    }\n    // 22 - Comment\n    // the encoding is always cp437.\n    const comment = options.ignoreComments ? \"\" : (decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22))\n\n    if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {\n      return new ZipFile(fd, centralDirectorySize, centralDirectoryOffset, totalSize, entryCount, comment, options)\n    }\n\n    // ZIP64 format\n\n    // ZIP64 Zip64 end of central directory locator\n    const zip64EocdlBuffer = Buffer.allocUnsafe(20)\n    const zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length\n    await readAndAssertNoEof(fd, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset)\n\n    // 0 - zip64 end of central dir locator signature = 0x07064b50\n    if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {\n      throw new Error(\"invalid zip64 end of central directory locator signature\")\n    }\n\n    // 4 - number of the disk with the start of the zip64 end of central directory\n    // 8 - relative offset of the zip64 end of central directory record\n    const zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8)\n    // 16 - total number of disks\n\n    // ZIP64 end of central directory record\n    const zip64EocdrBuffer = Buffer.allocUnsafe(56)\n    await readAndAssertNoEof(fd, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset)\n    // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n    if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {\n      throw new Error(\"invalid zip64 end of central directory record signature\")\n    }\n    // 4 - size of zip64 end of central directory record                8 bytes\n    // 12 - version made by                                             2 bytes\n    // 14 - version needed to extract                                   2 bytes\n    // 16 - number of this disk                                         4 bytes\n    // 20 - number of the disk with the start of the central directory  4 bytes\n    // 24 - total number of entries in the central directory on this disk         8 bytes\n    // 32 - total number of entries in the central directory            8 bytes\n    entryCount = readUInt64LE(zip64EocdrBuffer, 32)\n    // 40 - size of the central directory                               8 bytes\n    // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n    centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48)\n    // 56 - zip64 extensible data sector                                (variable size)\n    return new ZipFile(fd, readUInt64LE(zip64EocdrBuffer, 40), centralDirectoryOffset, totalSize, entryCount, comment, options)\n  }\n\n  throw new Error(\"end of central directory record signature not found\")\n}\n\nexport class ZipFile extends EventEmitter {\n  private readEntryCursor = 0\n  private isOpen = true\n\n  // noinspection JSUnusedGlobalSymbols\n  constructor(readonly fd: number, readonly centralDirectorySize: number, readonly centralDirectoryOffset: number, readonly fileSize: number, readonly entryCount: number, readonly comment: any, readonly options: ZipOptions) {\n    super()\n  }\n\n  async readEntries() {\n    this.readEntryCursor = 0\n    const buffer = Buffer.allocUnsafe(this.centralDirectorySize)\n    await readAndAssertNoEof(this.fd, buffer, 0, buffer.length, this.centralDirectoryOffset)\n\n    const entries = new Array<Entry>(this.entryCount)\n    for (let i = 0; i < this.entryCount; i++) {\n      entries[i] = this.readEntry(buffer)\n    }\n    return entries\n  }\n\n  async close() {\n    if (!this.isOpen) {\n      return\n    }\n\n    this.isOpen = false\n    return closeFile(this.fd)\n  }\n\n  private readEntry(buffer: Buffer): Entry {\n    const entry = new Entry()\n    // 0 - Central directory file header signature\n    const signature = buffer.readUInt32LE(this.readEntryCursor)\n    if (signature !== 0x02014b50) {\n      throw new Error(`invalid central directory file header signature: 0x${signature.toString(16)}`)\n    }\n\n    // 4 - Version made by\n    entry.versionMadeBy = buffer.readUInt16LE(this.readEntryCursor + 4)\n    // 6 - Version needed to extract (minimum)\n    entry.versionNeededToExtract = buffer.readUInt16LE(this.readEntryCursor + 6)\n    // 8 - General purpose bit flag\n    entry.generalPurposeBitFlag = buffer.readUInt16LE(this.readEntryCursor + 8)\n    // 10 - Compression method\n    entry.compressionMethod = buffer.readUInt16LE(this.readEntryCursor + 10)\n    // 12 - File last modification time\n    entry.lastModFileTime = buffer.readUInt16LE(this.readEntryCursor + 12)\n    // 14 - File last modification date\n    entry.lastModFileDate = buffer.readUInt16LE(this.readEntryCursor + 14)\n    // 16 - CRC-32\n    entry.crc32 = buffer.readUInt32LE(this.readEntryCursor + 16)\n    // 20 - Compressed size\n    entry.compressedSize = buffer.readUInt32LE(this.readEntryCursor + 20)\n    // 24 - Uncompressed size\n    entry.uncompressedSize = buffer.readUInt32LE(this.readEntryCursor + 24)\n    // 28 - File name length (n)\n    entry.fileNameLength = buffer.readUInt16LE(this.readEntryCursor + 28)\n    // 30 - Extra field length (m)\n    entry.extraFieldLength = buffer.readUInt16LE(this.readEntryCursor + 30)\n    // 32 - File comment length (k)\n    entry.fileCommentLength = buffer.readUInt16LE(this.readEntryCursor + 32)\n    // 34 - Disk number where file starts\n    // 36 - Internal file attributes\n    entry.internalFileAttributes = buffer.readUInt16LE(this.readEntryCursor + 36)\n    // 38 - External file attributes\n    entry.externalFileAttributes = buffer.readUInt32LE(this.readEntryCursor + 38)\n    // 42 - Relative offset of local file header\n    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(this.readEntryCursor + 42)\n\n    if (entry.generalPurposeBitFlag & 0x40) {\n      throw new Error(\"strong encryption is not supported\")\n    }\n\n    this.readEntryCursor += 46\n    const entryDataSize = entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength\n    buffer = buffer.slice(this.readEntryCursor, this.readEntryCursor + entryDataSize)\n    this.readEntryCursor += entryDataSize\n\n    // 46 - File name\n    const isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0\n    entry.fileName = this.options.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength)\n\n    // 46+n - Extra field\n    const fileCommentStart = entry.fileNameLength + entry.extraFieldLength\n    readExtraFields(buffer.slice(entry.fileNameLength, fileCommentStart), entry)\n\n    // 46+n+m - File comment\n    if (!this.options.ignoreComments) {\n      if (this.options.decodeStrings) {\n        entry.fileComment = decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8)\n      }\n      else {\n        entry.fileComment = buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength)\n      }\n    }\n\n    readZip64Entry(entry)\n\n    // check for Info-ZIP Unicode Path Extra Field (0x7075)\n    // see https://github.com/thejoshwolfe/yauzl/issues/33\n    if (this.options.decodeStrings) {\n      for (const extraField of entry.extraFields) {\n        if (extraField.id === 0x7075) {\n          if (extraField.data.length < 6) {\n            // too short to be meaningful\n            continue\n          }\n          // Version       1 byte      version of this extra field, currently 1\n          if (extraField.data.readUInt8(0) !== 1) {\n            // > Changes may not be backward compatible so this extra\n            // > field should not be used if the version is not recognized.\n            continue\n          }\n          // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n          // const oldNameCrc32 = extraField.data.readUInt32LE(1)\n          // if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {\n          //   // > If the CRC check fails, this UTF-8 Path Extra Field should be\n          //   // > ignored and the File Name field in the header should be used instead.\n          //   continue\n          // }\n          // UnicodeName   Variable    UTF-8 version of the entry File Name\n          entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true)\n          break\n        }\n      }\n    }\n\n    // validate file size\n    if (this.options.validateEntrySizes && entry.compressionMethod === 0) {\n      let expectedCompressedSize = entry.uncompressedSize\n      if (entry.isEncrypted) {\n        // traditional encryption prefixes the file data with a header\n        expectedCompressedSize += 12\n      }\n      if (entry.compressedSize !== expectedCompressedSize) {\n        throw new Error(\"compressed/uncompressed size mismatch for stored file: \" + entry.compressedSize + \" != \" + entry.uncompressedSize)\n      }\n    }\n\n    if (this.options.decodeStrings) {\n      const errorMessage = validateFileName(entry.fileName as string)\n      if (errorMessage != null) {\n        throw new Error(errorMessage)\n      }\n    }\n    return entry\n  }\n\n  async getDataPosition(entry: Entry): Promise<EntryDataRange> {\n    const buffer = Buffer.allocUnsafe(30)\n    await readAndAssertNoEof(this.fd, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader)\n    // 0 - Local file header signature = 0x04034b50\n    const signature = buffer.readUInt32LE(0)\n    if (signature !== 0x04034b50) {\n      throw new Error(`invalid local file header signature: 0x${signature.toString(16)}`)\n    }\n\n    // all this should be redundant\n    // 4 - Version needed to extract (minimum)\n    // 6 - General purpose bit flag\n    // 8 - Compression method\n    // 10 - File last modification time\n    // 12 - File last modification date\n    // 14 - CRC-32\n    // 18 - Compressed size\n    // 22 - Uncompressed size\n    // 26 - File name length (n)\n    const fileNameLength = buffer.readUInt16LE(26)\n    // 28 - Extra field length (m)\n    const extraFieldLength = buffer.readUInt16LE(28)\n    // 30 - File name\n    // 30+n - Extra field\n    const fileDataStart = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength\n    const fileDataEnd = fileDataStart + entry.compressedSize\n    if (entry.compressedSize !== 0) {\n      // bounds check now, because the read streams will probably not complain loud enough.\n      // since we're dealing with an unsigned offset plus an unsigned size, we only have 1 thing to check for.\n      if (fileDataEnd > this.fileSize) {\n        throw new Error(`file data overflows file bounds: ${fileDataStart} + ${entry.compressedSize} > ${this.fileSize}`)\n      }\n    }\n\n    return {\n      start: fileDataStart,\n      end: fileDataStart + entry.compressedSize,\n    }\n  }\n}\n\nexport interface EntryDataRange {\n  start: number\n  end: number\n}\n\nfunction readExtraFields(extraFieldBuffer: Buffer, entry: Entry) {\n  entry.extraFields = []\n  let i = 0\n  while (i < extraFieldBuffer.length - 3) {\n    const headerId = extraFieldBuffer.readUInt16LE(i)\n    const dataSize = extraFieldBuffer.readUInt16LE(i + 2)\n    const dataStart = i + 4\n    const dataEnd = dataStart + dataSize\n    if (dataEnd > extraFieldBuffer.length) {\n      throw new Error(\"extra field length exceeds extra field buffer size\")\n    }\n    const dataBuffer = Buffer.allocUnsafe(dataSize)\n    extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd)\n    entry.extraFields.push({\n      id: headerId,\n      data: dataBuffer,\n    })\n    i = dataEnd\n  }\n}\n\nfunction readZip64Entry(entry: Entry) {\n  if (entry.uncompressedSize === 0xffffffff ||\n    entry.compressedSize === 0xffffffff ||\n    entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n    // ZIP64 format\n    // find the Zip64 Extended Information Extra Field\n    let zip64EiefBuffer = null\n    for (const extraField of entry.extraFields) {\n      if (extraField.id === 0x0001) {\n        zip64EiefBuffer = extraField.data\n        break\n      }\n    }\n    if (zip64EiefBuffer == null) {\n      throw new Error(\"expected zip64 extended information extra field\")\n    }\n    let index = 0\n    // 0 - Original Size          8 bytes\n    if (entry.uncompressedSize === 0xffffffff) {\n      if (index + 8 > zip64EiefBuffer.length) {\n        throw new Error(\"zip64 extended information extra field does not include uncompressed size\")\n      }\n      entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index)\n      index += 8\n    }\n    // 8 - Compressed Size        8 bytes\n    if (entry.compressedSize === 0xffffffff) {\n      if (index + 8 > zip64EiefBuffer.length) {\n        throw new Error(\"zip64 extended information extra field does not include compressed size\")\n      }\n      entry.compressedSize = readUInt64LE(zip64EiefBuffer, index)\n      index += 8\n    }\n    // 16 - Relative Header Offset 8 bytes\n    if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n      if (index + 8 > zip64EiefBuffer.length) {\n        throw new Error(\"zip64 extended information extra field does not include relative header offset\")\n      }\n      entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index)\n      // noinspection JSUnusedAssignment\n      index += 8\n    }\n    // 24 - Disk Start Number      4 bytes\n  }\n}\n\nexport class Entry {\n  compressionMethod: number\n  generalPurposeBitFlag: number\n  lastModFileDate: number\n  lastModFileTime: number\n\n  versionMadeBy: number\n  versionNeededToExtract: number\n  crc32: number\n\n  fileName: string | Buffer\n  fileComment: string | Buffer\n  compressedSize: number\n  uncompressedSize: number\n  fileNameLength: number\n  extraFieldLength: number\n  fileCommentLength: number\n  internalFileAttributes: number\n  externalFileAttributes: number\n  relativeOffsetOfLocalHeader: number\n\n  extraFields: Array<any>\n\n  get isEncrypted() {\n    return (this.generalPurposeBitFlag & 0x1) !== 0\n  }\n  get isCompressed() {\n    return this.compressionMethod === 8\n  }\n}\n\nfunction validateFileName(fileName: string) {\n  if (fileName.indexOf(\"\\\\\") !== -1) {\n    return \"invalid characters in fileName: \" + fileName\n  }\n  if (/^[a-zA-Z]:/.test(fileName) || /^\\//.test(fileName)) {\n    return \"absolute path: \" + fileName\n  }\n  if (fileName.split(\"/\").indexOf(\"..\") !== -1) {\n    return \"invalid relative path: \" + fileName\n  }\n  // all good\n  return null\n}\n\nasync function readAndAssertNoEof(fd: number, buffer: Buffer, offset: number, length: number, position: number) {\n  if (length === 0) {\n    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file\n    return Buffer.alloc(0)\n  }\n\n  // noinspection UnnecessaryLocalVariableJS\n  const result = await read(fd, buffer, offset, length, position)\n  //   if (bytesRead < length) {\n  //     return callback(new Error(\"unexpected EOF\"))\n  //   }\n  return result\n}\n\nconst cp437 = '\\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ '\n\nfunction decodeBuffer(buffer: Buffer, start: number, end: number, isUtf8: boolean) {\n  if (isUtf8) {\n    return buffer.toString(\"utf8\", start, end)\n  }\n\n  let result = \"\"\n  for (let i = start; i < end; i++) {\n    result += cp437[buffer[i]]\n  }\n  return result\n}\n\nfunction readUInt64LE(buffer: Buffer, offset: number) {\n  // there is no native function for this, because we can't actually store 64-bit integers precisely.\n  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.\n  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.\n  const lower32 = buffer.readUInt32LE(offset)\n  const upper32 = buffer.readUInt32LE(offset + 4)\n  // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.\n  return upper32 * 0x100000000 + lower32\n  // as long as we're bounds checking the result of this function against the total file size,\n  // we'll catch any overflow errors, because we already made sure the total file size was within reason.\n}"]}
