"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createDifferentialPackage = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

/*
Approach like AppX block map, but with one difference - block not compressed individually, instead, the whole file is compressed using LZMA compression.
See (Package File in the developer readme) about compression. So, delta will be not ideal (because compressed data can change not only actually changed block in the file, but others,
and we don't set even dict size and default 64M is used), but full package size will be still relative small and will save initial download time/costs.
 */
// reduce dict size to avoid large block invalidation on change
let createDifferentialPackage = exports.createDifferentialPackage = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (archiveFile, archiveOptions, packager) {
        // Deflate to be able to decompress block map on the fly without 7za
        const args = (0, (_archive || _load_archive()).compute7zCompressArgs)("normal", "zip", { method: "Deflate" });
        args.push(archiveFile);
        // compute block map using compressed file data
        const blockMap = yield (0, (_blockMap || _load_blockMap()).computeBlockMap)(archiveFile, "lzma", process.env.ELECTRON_BUILDER_COMPRESSION_LEVEL || "9");
        // https://superuser.com/a/966241, use leading ~ symbol to add file to the end (and avoid file rewrite)
        const blockMapFile = yield packager.info.tempDirManager.getTempFile({ prefix: "~", suffix: "blockMap.yml" });
        yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(blockMapFile, (0, (_jsYaml || _load_jsYaml()).safeDump)(blockMap));
        yield (0, (_builderUtil || _load_builderUtil()).spawn)((_zipBin || _load_zipBin()).path7za, args.concat(blockMapFile), {
            cwd: _path.dirname(archiveFile)
        });
        // rename to final name (file order will be not changed and preserved as is)
        yield (0, (_builderUtil || _load_builderUtil()).exec)((_zipBin || _load_zipBin()).path7za, ["rn", archiveFile, _path.basename(blockMapFile), "blockMap.yml"]);
    });

    return function createDifferentialPackage(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
    };
})();
//# sourceMappingURL=nsisPackage.js.map


var _zipBin;

function _load_zipBin() {
    return _zipBin = require("7zip-bin");
}

var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = require("js-yaml");
}

var _path = _interopRequireWildcard(require("path"));

var _archive;

function _load_archive() {
    return _archive = require("../archive");
}

var _blockMap;

function _load_blockMap() {
    return _blockMap = require("../blockMap");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }