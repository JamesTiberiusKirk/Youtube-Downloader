"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.computeBlockMap = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

let computeBlocks = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (fd, range) {
        const chunkSize = 64 * 1024;
        const buffer = Buffer.allocUnsafe(chunkSize);
        const blocks = [];
        for (let offset = range.start; offset < range.end; offset += chunkSize) {
            const actualChunkSize = Math.min(range.end - offset, chunkSize);
            yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, buffer, 0, actualChunkSize, offset);
            const hash = (0, (_crypto || _load_crypto()).createHash)("sha256");
            hash.update(actualChunkSize === chunkSize ? buffer : buffer.slice(0, actualChunkSize));
            blocks.push(hash.digest("base64"));
        }
        return blocks;
    });

    return function computeBlocks(_x, _x2) {
        return _ref.apply(this, arguments);
    };
})();

let computeBlockMap = exports.computeBlockMap = (() => {
    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (archiveFile, compressionMethod, compressionLevel) {
        const zip = yield (0, (_zip || _load_zip()).openZip)(archiveFile);
        try {
            const entries = yield zip.readEntries();
            const files = yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(entries, (() => {
                var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (entry) {
                    const blocks = yield computeBlocks(zip.fd, (yield zip.getDataPosition(entry)));
                    return {
                        name: entry.fileName.replace(/\\/g, "/"),
                        size: entry.compressedSize,
                        blocks
                    };
                });

                return function (_x6) {
                    return _ref3.apply(this, arguments);
                };
            })(), { concurrency: 8 });
            return {
                blockSize: 64,
                hashMethod: "sha256",
                compressionMethod,
                compressionLevel,
                files
            };
        } finally {
            yield zip.close();
        }
    });

    return function computeBlockMap(_x3, _x4, _x5) {
        return _ref2.apply(this, arguments);
    };
})();
//# sourceMappingURL=blockMap.js.map


var _crypto;

function _load_crypto() {
    return _crypto = require("crypto");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _zip;

function _load_zip() {
    return _zip = require("./nsis/zip");
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }